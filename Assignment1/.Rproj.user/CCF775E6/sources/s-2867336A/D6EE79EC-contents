library(tidyverse)
library(MineICA)
#functions
subset_data <- function(tissue, data, sample_att){
  #subset tissue
  sample_att %>% #select only the required tissue
    filter(SMTSD == tissue) %>%
    dplyr::select(SAMPID, SMTSD) -> sample_id_subset
  sample_id_subset <- sample_id_subset$SAMPID #conver to vector
  #make sure these columns are actually in the data
  sample_id_subset <- sample_id_subset[sample_id_subset %in% colnames(data)]
  
  #subset data according to tissue
  data %>% 
    dplyr::select(c(sample_id_subset)) -> data_tissue
  return(data_tissue)
}

reduce_data <- function(data, capture_sd){
  #takes in a matrix (data) and the minimum amoount of sd to be captured
  pca <- prcomp(data, center = T, scale. = T)
  index <- which(cumsum(pca$sdev)/sum(pca$sdev) >= capture_sd)[1]
  data <- pca$x[,1:index]
  #data <- whiten(data, method = "PCA")
  return(data)
}

# get_S <- function(k, n, data){
#   #perform ica n times and take high kurtosis values only
#   S <- 0
#   tol <- 1
#   for(i in 1:n){
#     #repeat n times because optimization is not deterministic
#     res <- fastICA_modfied(data, k, 
#                            alg.typ = "parallel",
#                            alpha = 1.0,
#                            method = "R")
#     if(res$tol < tol){
#       tol <- res$tol
#       S <- res$S
#     }
#   }
#   kurtosis_vector <- apply(S, 2, kurtosis)
#   kurtosis_vector <- kurtosis_vector > 0
#   S <- S[, kurtosis_vector] #only select columns with a kurtosis > 0, excess kurtosis > 3
#   return(S)
# }

get_S <- function(k, n, data){
  res <- clusterFastICARuns(X=data, nbComp=k, alg.type="parallel", 
                            nbIt=n, funClus="hclust", method="average")
  cutoff_vector <- res$Iq > 0.9
  S <- res$S[, cutoff_vector]
  #kurtosis_vector <- apply(S, 2, kurtosis)
  #kurtosis_vector <- kurtosis_vector > 0
  #S <- S[, kurtosis_vector] #only select columns with a kurtosis > 0, excess kurtosis > 3
  return(S)
}

get_module <- function(col){
  #Takes in a column from the S matrix and returns the gene names in that module
  m <- mean(col)
  sd <- sd(col)
  cutoff_low <- m - 3*sd
  cutoff_high <- m + 3*sd
  cutoff_vector <- col < cutoff_low | col > cutoff_high
  #gene_names <- data_name[cutoff_vector, ]$Name
  module <- as.numeric(cutoff_vector)
  return(module)
}


get_module_df <- function(tissue, data, sample_att){
  #subset tissue
  sample_att %>% #select only the required tissue
    filter(SMTSD == tissue) %>%
    dplyr::select(SAMPID, SMTSD) -> sample_id_subset
  sample_id_subset <- sample_id_subset$SAMPID #conver to vector
  #make sure these columns are actually in the data
  sample_id_subset <- sample_id_subset[sample_id_subset %in% colnames(data)]
  
  #subset data according to tissue
  data %>% 
    dplyr::select(c("Name", "Description", sample_id_subset)) -> data_tissue
  
  #only numbers
  data_tissue %>%
    dplyr::select(sample_id_subset) -> data_mat
  
  #preprocess data
  #data_mat <- normalize.quantiles(as.matrix(data_mat))
  data_mat <- reduce_data(data_mat, PCA)
  
  #variables
  K <- dim(data_mat)[2] #number of independant components
  #ITER <- 5 #number of times fastICA should be repeated
  
  #Get source matrix
  S <- get_S(K, ITER, data_mat)
  
  #get all modules
  modules_df <- as.data.frame(apply(S, 2, get_module))
  colnames(modules_df) <- paste(tissue, 1:dim(modules_df)[2], sep = " M")
  #modules_list <- get_module(S[,1])
  return(modules_df)
}
